"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isRedoclyRegistryURL = exports.RedoclyClient = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const os_1 = require("os");
const colorette_1 = require("colorette");
const registry_api_1 = require("./registry-api");
const TOKEN_FILENAME = '.redocly-config.json';
class RedoclyClient {
    constructor() {
        this.loadToken();
        this.registryApi = new registry_api_1.RegistryApi(this.accessToken);
    }
    hasToken() {
        return !!this.accessToken;
    }
    loadToken() {
        if (process.env.REDOCLY_AUTHORIZATION) {
            this.accessToken = process.env.REDOCLY_AUTHORIZATION;
            return;
        }
        const credentialsPath = path_1.resolve(os_1.homedir(), TOKEN_FILENAME);
        if (fs_1.existsSync(credentialsPath)) {
            const credentials = JSON.parse(fs_1.readFileSync(credentialsPath, 'utf-8'));
            this.accessToken = credentials && credentials.token;
        }
    }
    isAuthorizedWithRedocly() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.hasToken() && !!(yield this.getAuthorizationHeader());
        });
    }
    verifyToken(accessToken, verbose = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!accessToken)
                return false;
            return this.registryApi.setAccessToken(accessToken).authStatus(verbose);
        });
    }
    getAuthorizationHeader() {
        return __awaiter(this, void 0, void 0, function* () {
            // print this only if there is token but invalid
            if (this.accessToken && !(yield this.verifyToken(this.accessToken))) {
                process.stderr.write(`${colorette_1.yellow('Warning:')} invalid Redocly API key. Use "npx @redocly/openapi-cli login" to provide your API key\n`);
                return undefined;
            }
            return this.accessToken;
        });
    }
    login(accessToken, verbose = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const credentialsPath = path_1.resolve(os_1.homedir(), TOKEN_FILENAME);
            process.stdout.write(colorette_1.gray('\n  Logging in...\n'));
            const authorized = yield this.verifyToken(accessToken, verbose);
            if (!authorized) {
                process.stdout.write(colorette_1.red('Authorization failed. Please check if you entered a valid API key.\n'));
                process.exit(1);
            }
            this.accessToken = accessToken;
            const credentials = {
                token: accessToken,
            };
            fs_1.writeFileSync(credentialsPath, JSON.stringify(credentials, null, 2));
            process.stdout.write(colorette_1.green('  Authorization confirmed. ‚úÖ\n\n'));
        });
    }
    logout() {
        const credentialsPath = path_1.resolve(os_1.homedir(), TOKEN_FILENAME);
        if (fs_1.existsSync(credentialsPath)) {
            fs_1.unlinkSync(credentialsPath);
        }
        process.stdout.write('Logged out from the Redocly account. ‚úã\n');
    }
}
exports.RedoclyClient = RedoclyClient;
function isRedoclyRegistryURL(link) {
    const domain = process.env.REDOCLY_DOMAIN || 'redoc.ly';
    if (!link.startsWith(`https://api.${domain}/registry/`))
        return false;
    const registryPath = link.replace(`https://api.${domain}/registry/`, '');
    const pathParts = registryPath.split('/');
    // we can be sure, that there is job UUID present
    // (org, definition, version, bundle, branch, job, "openapi.yaml" ü§¶‚Äç‚ôÇÔ∏è)
    // so skip this link.
    // FIXME
    if (pathParts.length === 7)
        return false;
    return true;
}
exports.isRedoclyRegistryURL = isRedoclyRegistryURL;
